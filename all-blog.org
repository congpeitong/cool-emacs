#+hugo _base_dir: e:/my_source_code/congpeitong.github.io/
#+hugo_section: posts
#+hugo_auto_set_lastmod: t
#+hugo_custom_front_matter: :author "congpeitong"
#+hugo_code_fence: nil
#+STARTUP: overview top-level headlines only
* Blog Ideas
** DONE shell编程基础                                         :@Linux:Shell:
:PROPERTIES:
:EXPORT_FILE_NAME: 2022-11-13-shell-program
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-13 周日 09:31]
:END:
*** 简介

+ shell是一个用C语言编写的程序，通过shell用户可以访问操作系统内核服务。
+ shell既是一种命令语言又是一种程序设计语言。
+ Shell script 是一种为shell编写的脚本程序。shell编程一般是指shell脚本编程，不是指开发shell自身
+ shell编程跟Java，PHP编程一样，只要有一个能编写代码的文本编译器和一个能解释执行的脚本解释器就可以了
+ Linux shell解释器种类繁多，一个系统就可以存在多个shell, 可以通过 cat /etc/shells命令查看系统中安装的shell解释器
+ Bash由于易用和免费，在日常生活中被广泛使用。同时，Bash也是大多数Linux系统默认的Shell

*** shell解释器

java需要虚拟机解释器，同理shell脚本也需要解释器，如下所示：

#+begin_src sh
    #命令：
    cat /etc/shells
    #输出如下：
    /bin/sh
    /bin/bash
    /sbin/nologin
    /bin/dash
    /bin/tcsh
    /bin/csh
#+end_src

*** 入门
**** 编写脚本

新建 /export/hello.sh 文件内容如下：
#+begin_src sh

#!/bin/bash
echo 'hello world'

#+end_src

#!是一个约定的标记，它告诉系统这个脚本使用哪种解释器来执行，即使用哪一种shell。

echo命令用于向窗口输出文本。

**** 执行脚本
***** 执行方式一

#+begin_src sh
/bin/sh hello.sh
#+end_src


或者

#+begin_src sh
/bin/bash hello.sh
#+end_src


sh是bash的快捷方式

***** 执行方式二

方式一的简化方式:

#+begin_src sh
  bash hello.sh
  sh hello.sh
#+end_src

由于PATH环境变量中增加了/bin/目录，所以使用/bin/sh 等类似指令时，可以省略 /bin

***** 执行方式三

./文件名

#+begin_src sh
./hello.sh
#+end_src

如果遇到权限不够，执行下面命令

#+begin_src sh
  chmod 755 hello.sh
  #再次执行
  ./hello.sh
#+end_src
*** shell 变量
**** 简介
1. 在shell脚本中定义变量时，变量名子不加美元符号$，例如：

   your_name="congpeitong"
2. 注意：变量名和等号之间不能有空格
3.变量名的命名需遵守如下规则：
+ 命名只能使用英文字母，数字和下划线，首个字母不能以下划线开头。
+ 中间不能有空格，可以使用下划线_。
+ 不能使用标点符号。
+ 不能使用bash里面的关键字（可用help命令查看保留关键字）。

4. 有效的Shell变量名示例如下：
   #+begin_src sh
     RUNOOB
     LD_LIBARY_PATH
     _var
     var2
   #+end_src
5. 无效的变量命名
   #+begin_src sh
     ?var=123
     user*name=runoob
  #+end_src
6. 除了显式的直接赋值还可以用语句给变量赋值(将/etc目录下的文件名循环出来)
   + for file in `ls /etc`
   + for file in $(ls /etc)
**** 使用变量
使用一个定义过的变量，只要在变量名前面加美元符号即可，如：
#+begin_src sh
your_name="zhangsan"
echo $your_name
echo ${your_name}
#+end_src
变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：
#+begin_src sh
for skill in java php python; do
    echo "I am good at ${skill}Script"
done
#+end_src

如果不给 skill 变量加花括号，写成echo "I am good at $skillScript"，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。

推荐给所有变量加上花括号，这是个好的编程习惯。

已定义的变量，可以被重新定义，如：
#+begin_src sh
your_name="tom"
echo $your_name
your_name="alibaba"
echo $your_name
#+end_src
这样写是合法的，但注意，第二次赋值的时候不能写$your_name="alibaba"，使用变量的时候才加美元符。
**** 删除变量
使用 unset 命令可以删除变量。语法：
#+begin_src sh
unset variable_name
#+end_src
变量被删除后不能再次使用。unset 命令不能删除只读变量。
***** 实例
#+begin_src sh
#!/bin/sh
myUrl="http://www.gitee.com"
unset myUrl
echo $myUrl
#+end_src
以上实例执行没有任何输出
**** 只读变量
使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。
#+begin_src sh

  #!/bin/bash
  myUrl="http://www.google.com"
  readonly myUrl
  myUrl="http://www.runoob.com"

#+end_src
运行结果如下
#+begin_src sh
/bin/sh: NAME: This variable is read only.
#+end_src
**** 字符串
字符串是 shell 编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。
1. 单引号
   #+begin_src sh
     skill='java'
     str='I am goot at $skill'
     echo $str
   #+end_src
   输出结果为：
   #+begin_src sh
     I am goot at $skill
   #+end_src
单引号字符串的限制
+ 单引号里面的任何字符都会原样输出，单引号之中的变量是无效的
+ 单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但是可以成对出现，作为字符串拼接使用
2. 双引号
   #+begin_src sh
     skill='java'
     str="I am goot at $skill"
     echo $str
   #+end_src
   输出结果为：
   #+begin_src sh
     I am goot at java
   #+end_src
   双引号的优点
   + 双引号里可以有变量
   + 双引号里可以出现转义字符
3. 获取字符串长度
   #+begin_src sh
     skill='java'
     echo ${skill}    # 输出结果: java
     echo ${#skill}   # 输出结果: 4
     或者:  expr length "iamlilei"   #输出结果:  8
   #+end_src
4. 提取子字符串
   + substring(2)
   + substring(2,3)
   以下实例从字符串第二个字符开始截取四个字符
   #+begin_src sh
     str="I am goot at $skill"
     echo ${str:2}    # 输出结果为: am goot at java  从第二个字符开始截取,到结尾
     echo ${str:2:2}    # 输出结果为: am  从第二个字符开始截取,截取2个字符
   #+end_src
5. 查找子字符串
查找字符i或者o的位置（哪个字母先出现就计算哪个）
#+begin_src sh
str="I am goot at  $skill"
echo `expr index "$str" am`    # 输出是: 3
或者:
expr index "iamlilei" am      #输出结果: 2   返回在STRING中找到CHARS字符串的位置；否则，返回0
#+end_src
**** 传递参数
我们可以在执行脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。

n代表一个数字，1为执行脚本的第一个参数，2为执行脚本的第二个参数，依次类推

以下实例我们将向脚本传递三个参数，并分别输出，其中$0为执行的文件名

vim /export/sh/param.sh
#+begin_src sh

  #!/bin/bash
  echo "Shell 传递参数实例！";
  echo "执行的文件名：$0";
  echo "第一个参数为：$1";
  echo "第二个参数为：$2";
  echo "第三个参数为：$3";

#+end_src
执行脚本
#+begin_src sh
$ ./param.sh 1 2 3
#+end_src
shell 传递参数实例输出
#+begin_src sh

  执行的文件名：./param.sh
  第一个参数为：1
  第二个参数为：2
  第三个参数为：3

#+end_src

几个特殊字符用来处理参数:
| 参数处理 | 说明                                                                                                                        |
|----------+-----------------------------------------------------------------------------------------------------------------------------|
| $#       | 传递到脚本的参数个数                                                                                                        |
| $*       | 以一个单字符串显示所有向脚本传递的参数。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。                      |
| $$       | 脚本运行的当前进程 ID 号                                                                                                    |
| $!       | 后台运行的最后一个进程的 ID 号                                                                                              |
| $@       | 与 $*相同，但是使用时加引号，并在引号中返回每个参数。   如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 |
| $-       | 显示 Shell 使用的当前选项，与 set 命令功能相同。                                                                            |
| $?       | 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。
                                                                                                                            |
#+begin_src sh

  #!/bin/bash
  echo "Shell 传递参数实例！";
  echo "第一个参数为：$1";
  echo "参数个数为：$#";
  echo "传递的参数作为一个字符串显示：$*";

#+end_src
输出如下：

#+begin_src sh
$ chmod +x test.sh
$ ./test.sh 1 2 3
Shell 传递参数实例！
第一个参数为：1
参数个数为：3
传递的参数作为一个字符串显示：1 2 3
#+end_src
$* 与 $@ 区别：
+ 相同点：都是引用所有参数
+ 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。
#+begin_src sh
#!/bin/bash
echo "-- $* 演示 ---"
for i in "$*"; do
    echo $i
done
echo "-- $@ 演示 ---"
for i in "$@"; do
    echo $i
done
#+end_src
执行脚本输出结果如下：
#+begin_src sh
$ chmod +x test.sh

$ ./test.sh 1 2 3

-- $* 演示 ---
1 2 3

-- $@ 演示 ---
1
2
3

#+end_src
*** shell算术运算符
**** 简介
Shell 和其他编程一样，支持包括：算术、关系、布尔、字符串等运算符。

原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 expr。

expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

例如，两个数相加：

#+begin_src sh
val=`expr 2 + 2`
echo $val
#+end_src
注意：
+ 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2。
+ 完整的表达式要被 ` 包含，注意不是单引号，在 Esc 键下边。
+ 下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：
  | 运算符 | 说明                                          | 举例                         |
  |--------+-----------------------------------------------+------------------------------|
  | +      | 加法                                          | expr $a + $b 结果为 30。     |
  | -      | 减法                                          | expr $a - $b 结果为 -10。    |
  | *      | 乘法                                          | expr $a * $b 结果为 200。    |
  | /      | 除法                                          | expr $b / $a 结果为 2。      |
  | %      | 取余                                          | expr $b % $a 结果为 0。      |
  | =      | 赋值                                          | a=$b 将把变量 b 的值赋给 a。 |
  | ==     | 相等。用于比较两个数字，相同则返回 true。     | [ $a == $b ] 返回 false。    |
  | !=     | 不相等。用于比较两个数字，不相同则返回 true。 | [ $a != $b ] 返回 true。     |
  |        |                                               |                              |
  注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。
**** 举例
#+begin_src sh

  #!/bin/bash
  a=4
  b=20
  #加法运算
  each expr $a + $b
  #减法运算
  echo expr $a - $b
  #乘法运算，注意*号前面需要反斜杠
  echo expr $a \* $b
  #除法运算
  echo $a / $b
  此外，还可以通过(())、$(())、$[]进行算术运算。
   ((a++))
  echo "a = $a"
  c=$((a + b))
  d=$[a + b]
  echo "c = $c"
  echo "d = $d"

#+end_src
*** 流程控制
**** if
if 语句语法格式：
#+begin_src sh

if condition; then
    command1
    command2
    ...
    commandN
fi

#+end_src
demo:
#+begin_src sh

  [root@hadoop01 export]# cat if_test.sh
  #!/bin/bash
  a=20
  if [ $a -gt 10 ]; then
          echo "a 大于 10"
  fi

#+end_src
末尾的 fi 就是 if 倒过来拼写，后面还会遇到类似的。
**** if else
语法格式
#+begin_src sh

if condition; then
    command1
    command2
    ...
    commandN
else
    command
fi

#+end_src
**** if else-if else
语法格式：
#+begin_src sh

if condition1; then
    command1
elif condition2; then
    command2
else
    commandN
fi

#+end_src
以下实例判断两个变量是否相等：

*关系运算符*

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

下表列出了常用的关系运算符，假设变量a为10，变量b为20：
| 运算符 | 说明                                                  | 英文                     | 举例                       |
|--------+-------------------------------------------------------+--------------------------+----------------------------|
| -eq    | 检测两个数是否相等，相等返回 true。                   | equal                    | [ $a -eq $b ] 返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | not equal                | [ $a -ne $b ] 返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | greater than             | [ $a -gt $b ] 返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | less than                | [ $a -lt $b ] 返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | Greater than or equal to | [ $a -ge $b ] 返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | Less than or equal to    | [ $a -le $b ] 返回 true。                           |
案例：
#+begin_src sh

  #!/bin/bash

  a=20
  b=10

  # 需求1: 判断 a 是否 100
  if [ $a > 100 ]; then
          echo "$a 大于 100"
  fi


  # 需求2: 判断 a 是否等于 b
  if [ $a -eq $b ]; then
          echo "$a 等于 $b"
  else
          echo "$a 不等于 $b"
  fi

  # 需求3: 判断 a 与 b 比较
  if [ $a -lt $b ]; then
          echo "$a 小于 $b"
  elif [ $a -eq $b ]; then
          echo "$a 等于 $b"
  else
          echo "$a 大于 $b"
  fi


  # 需求4: 判断 (a + 10) 和 (b * b) 比较大小
  if test $[ a + 10 ] -gt $[ b * b ]; then
          echo "(a+10) 大于 (b * b)"
  else
          echo "(a+10) 小于或等于 (b*b)"
  fi

#+end_src
*** for循环
格式：
#+begin_src sh
for variable in (list); do
    command
    command
    ...
done
#+end_src
示例：
#+begin_src sh
# 需求1: 遍历 1~5
for i in 1 2 3 4 5; do
        echo $i;
done
# 需求2: 遍历 1~100
for i in {1..100}; do
        echo $i
done
# 需求3: 遍历 1~100之间的奇数
for i in {1..100..2}; do
        echo $i
done
# 需求4: 遍历 根目录 下的内容
for f in `ls /`; do
        echo $f
done
#+end_src
*** while语句
while 循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：
#+begin_src sh
while condition; do
    command
done
#+end_src
需求: 计算 1~100 的和:
#+begin_src sh
#!/bin/bash

sum=0
i=1
while [ $i -le 100 ]; do
        sum=$[ sum + i]
        i=$[ i + 1 ]
done

echo $sum
#+end_src
执行脚本输出：5050

使用中使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：Bash let 命令：http://www.runoob.com/linux/linux-comm-let.html。
*** 无限循环
无限循环语法格式：
#+begin_src sh
    while true; do
        command
    done
    #需求: 每隔1秒 打印一次当前时间
    while true; do
          date
          sleep 1
    done
#+end_src
*** case(swith)
Shell case 语句为多选择语句。可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case 语句格式如下：
#+begin_src sh
case 值 in

 模式1)
     command1
     command2
     ...
     commandN
     ;;
 模式2）
        command1
     command2
     ...
     commandN
     ;;
esac
#+end_src
case 工作方式如上所示。取值后面必须为单词 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。

取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。

下面的脚本提示输入 1 到 4，与每一种模式进行匹配：
#+begin_src sh
echo '输入 1 到 4 之间的数字:'

read aNum

case $aNum in
    1)  echo '你选择了 1'
    ;;

    2)  echo '你选择了 2'
    ;;

    3)  echo '你选择了 3'
    ;;

    4)  echo '你选择了 4'
    ;;

    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac
#+end_src
输入不同的内容，会有不同的结果，例如：
#+begin_src sh
输入 1 到 4 之间的数字:

你输入的数字为:

3

你选择了 3
#+end_src

*** 跳出循环
在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell 使用两个命令来实现该功能：break 和 continue。
*** *break* 命令
break 命令允许跳出所有循环（终止执行后面的所有循环）。
#+begin_src sh

# 需求: 执行死循环 每隔1秒打印当前时间, 执行10次停止
i=0;
while true; do
        sleep 1
        echo $i `date +"%Y-%m-%d %H:%M:%S"`

        i=$[ i + 1]
        if [ $i -eq 10 ]; then
                break
        fi
done

#+end_src

*** continue
continue 命令与 break 命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。
#+begin_src sh
# 需求: 打印 1~30, 注意 跳过3的倍数

for i in {1..30}; do
        if test $[ i % 3 ] -eq 0; then
                continue
        fi
        echo $i
done
#+end_src

*** 函数使用
**** 函数快速入门
***** 格式
#+begin_src sh
[ function ] funname()
{
    action;
    [return int;]
}
#+end_src
+ 可以带 function fun() 定义，也可以直接 fun() 定义,不带任何参数。
+ 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。return 后跟数值 n(0-255)
**** 快速入门
#+begin_src sh
demoFun () {
    echo "这是我的第一个 shell 函数!"
}
echo "-----函数开始执行-----"
demoFun
echo "-----函数执行完毕-----"
#+end_src
**** 传递参数给函数
在 Shell 中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...

带参数的函数示例：
#+begin_src sh
funWithParam(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
#+end_src
输出结果：
#+begin_src sh
第一个参数为 1 !

第二个参数为 2 !

第十个参数为 10 !

第十个参数为 34 !

第十一个参数为 73 !

参数总数有 11 个!

作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !
#+end_src
注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。

另外，还有几个特殊字符用来处理参数：
| 参数处理 | 说明                                                 |
|----------+------------------------------------------------------|
| $#       | 传递到脚本的参数个数                                 |
| $*       | 以一个单字符串显示所有向脚本传递的参数               |
| $$       | 脚本运行的当前进程 ID 号                             |
| $!       | 后台运行的最后一个进程的 ID 号                       |
| $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。 |
| $-       | 显示 Shell 使用的当前选项，与 set 命令功能相同。     |
| $?       | 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。                                                     |
*** 数组
**** 定义数组
数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（。

与大部分编程语言类似，数组元素的下标由 0 开始。

Shell 数组用括号来表示，元素用空格符号分割开，语法格式如下：

array_name=(value1 value2 value3 ... valuen)

*示例*
#+begin_src sh
my_array=(A B "C" D)

我们也可以使用下标来定义数组:

array_name[0]=value0

array_name[1]=value1

array_name[2]=value2
#+end_src
**** 读取数组
读取数组元素值的一般格式是：
#+begin_src sh
${array_name[index]}
#+end_src
*示例*
#+begin_src sh
#!/bin/bash

my_array=(A B "C" D)

echo "第一个元素为: ${my_array[0]}"

echo "第二个元素为: ${my_array[1]}"

echo "第三个元素为: ${my_array[2]}"

echo "第四个元素为: ${my_array[3]}"
#+end_src
执行脚本，输出结果如下所示：
#+begin_src sh
第一个元素为: A
第二个元素为: B
第三个元素为: C
第四个元素为: D
#+end_src
*获取数组中的所有元素*

使用 @ 或 * 可以获取数组中的所有的元素，例如：
#+begin_src sh
my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo "数组的元素为: ${my_array[*]}"
echo "数组的元素为: ${my_array[@]}"
#+end_src
执行脚本结果如下所示：
#+begin_src sh
数组的元素为: A B C D
数组的元素为: A B C D
#+end_src
*获取数组长度*

获取数组长度方法与获取字符串长度的方法相同。例如：
#+begin_src sh
my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo "数组元素个数为: ${#my_array[*]}"
echo "数组元素个数为: ${#my_array[@]}"
#+end_src
执行脚本，结果如下：
#+begin_src sh
数组元素个数为: 4
数组元素个数为: 4
#+end_src
**** 遍历数组
***** 方式1
#+begin_src sh
my_arr=(AA BB CC)
for var in ${my_arr[*]}
do
  echo $var
done
#+end_src
***** 方式2
#+begin_src sh
my_arr=(AA BB CC)
my_arr_num=${#my_arr[*]}
for((i=0;i<my_arr_num;i++));
do
  echo "-----------------------------"
  echo ${my_arr[$i]}
done
#+end_src
*** 加载其它文件的变量
**** 简介
和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。

Shell 文件包含的语法格式如下：
#+begin_src sh
. filename   # 注意点号(.)和文件名中间有一空格

或

source filename
#+end_src
**** *练习*

定义两个文件 test1.sh 和 test2.sh，在 test1 中定义一个变量arr=(java c++ shell),在 test2 中对arr进行循环打印输出。
+ 第一步  vim test1.sh
  #+begin_src sh
    #!/bin/bash
    my_arr=(AA BB CC)
  #+end_src

+ 第二步 vim test2.sh
  #+begin_src sh
    #!/bin/bash
    source ./test1.sh  # 加载test1.sh 的文件内容
    for var in ${my_arr[*]}
    do
      echo $var
    done
  #+end_src

+ 第三步 执行 test2.sh
  #+begin_src sh
    sh test2.sh
  #+end_src
**** 好处
1. 数据源 和 业务处理 分离
2. 复用代码扩展性更强

** DONE Nginx基础                                                    :@Nginx:
:PROPERTIES:
:EXPORT_FILE_NAME: 2022-11-14-nginx-base
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-14 周一 08:56]
:END:
*** Nginx 基本命令
#+begin_src shell


  # 1. 启动
  start nginx
  ningx.exe
  start nginx -c conf/nginx.conf #特殊设置nginx的配置文件路径
  # 2. 暂停
  nginx.exe -s stop # 快速暂停
  nginx.exe -s quit # 完整有序的停止nginx
  # 3. 重启
  nginx -s reload
  # 4. Windows下查看Nginx进程
  tasklist /fi "imagename eq nginx.exe"

#+end_src

** DONE Mysql 基础                                                  :@Mysql:
:PROPERTIES:
:EXPORT_FILE_NAME: 2022-11-15-mysql-base
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-15 周二 14:36]
:END:
*** 数据库的好处
1. 持久化数据到本地
2. 可以实现结构化查询，方便管理

*** 数据库相关概念
1. DB：数据库，保存一组有组织的数据的容器
2. DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据
3. SQL:结构化查询语言，用于和DBMS通信的语言

*** 数据库存储数据的特点
1. 将数据放到表中，表再放到库中
2. 一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。
3. 表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。
4. 表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”
5. 表中的数据是按行存储的，每一行类似于java中的“对象”。

*** MySQL服务的启动和停止

	+ net start 服务名（启动服务）
	+ net stop 服务名（停止服务）

*** MySQL服务的登录和退出

	+ 方式一：通过mysql自带的客户端只限于root用户

	+ 方式二：通过windows自带的客户端
      #+begin_src shell
        # 登录
        mysql 【-h主机名 -P端口号 】-u用户名 -p密码

        # 退出：
        exit / ctrl+C

      #+end_src


*** MySQL的常见命令

1. 查看当前所有的数据库

	 show databases;

2. 打开指定的库

   use 库名

3. 查看当前库的所有表

   show tables;

4. 查看其它库的所有表

   show tables from 库名;

5. 创建表
   #+begin_src sql
     create table 表明(
         列名 列类型,
         列名 列类型,
         ...
     );
   #+end_src
6. 查看表结构

	desc 表名;

7. 查看服务器的版本
	+ 方式一：登录到mysql服务端

      select version();

	+ 方式二：没有登录到mysql服务端

      mysql --version/mysql --V

*** MySQL的语法规范
1. 不区分大小写,但建议关键字大写，表名、列名小写
2. 每条命令最好用分号结尾
3. 每条命令根据需要，可以进行缩进 或换行
4. 注释

	 单行注释：#注释文字

	 单行注释：-- 注释文字

 	 多行注释：/* 注释文字  */


*** SQL的语言分类
DQL（Data Query Language）：数据查询语言select

DML(Data Manipulate Language):数据操作语言insert 、update、delete

DDL（Data Define Languge）：数据定义语言create、drop、alter

TCL（Transaction Control Language）：事务控制语言commit、rollback

*** SQL的常见命令

+ show databases； 查看所有的数据库
+ use 库名； 打开指定 的库
+ show tables ; 显示库中的所有表
+ show tables from 库名;显示指定库中的所有表
+ 创建表
  #+begin_src sql
  	create table 表名(
		  字段名 字段类型,
		  字段名 字段类型
	    );
  #+end_src
+ desc 表名; 查看指定表的结构
+ select * from 表名;显示表中的所有数据

*** 基础查询
+ 语法：
  #+begin_src sql
     SELECT 要查询的东西
    【FROM 表名】;
  #+end_src
	类似于Java中 :System.out.println(要打印的东西);
+ 特点：
  1. 通过select查询完的结果 ，是一个虚拟的表格，不是真实存在
  2. 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数

*** 条件查询
+ 条件查询：根据条件过滤原始表的数据，查询到想要的数据
  #+begin_src sql
     select
		要查询的字段|表达式|常量值|函数
	   from
		表
	   where
		条件 ;
  #+end_src

**** 分类：
1. 条件表达式
   + 示例：salary>10000
   + 条件运算符：> < >= <= = != <>

2. 逻辑表达式
   + 示例：salary>10000 && salary<20000
   + 逻辑运算符：

     and（&&）:两个条件如果同时成立，结果为true，否则为false

     or(||)：两个条件只要有一个成立，结果为true，否则为false

     not(!)：如果条件成立，则not后为false，否则为true

3. 模糊查询
	+ 示例：last_name like 'a%'
*** 排序查询
+ 语法：
  #+begin_src sql

	select
		要查询的东西
	from
		表
	where
		条件
	order by 排序的字段|表达式|函数|别名 【asc|desc】

 #+end_src
*** 常见函数
**** 单行函数
1. 字符函数
   concat拼接

   substr截取子串

   upper转换成大写

   lower转换成小写

   trim去前后指定的空格和字符

   ltrim去左边空格

   rtrim去右边空格

   replace替换

   lpad左填充

   rpad右填充

   instr返回子串第一次出现的索引

   length 获取字节个数

2. 数学函数

   round 四舍五入

   rand 随机数

   floor向下取整

   ceil向上取整

   mod取余

   truncate截断

3. 日期函数

   now当前系统日期+时间

   curdate当前系统日期

   curtime当前系统时间

   str_to_date 将字符转换成日期

   date_format将日期转换成字符

4. 流程控制函数
   #+begin_src sql
    if 处理双分支
		case语句 处理多分支
			情况1：处理等值判断
			情况2：处理条件判断

   #+end_src


5. 其他函数
   version版本

   database当前库

   user当前连接用户

**** 分组函数

sum 求和

max 最大值

min 最小值

avg 平均值

count 计数

+ 特点：
  1. 以上五个分组函数都忽略null值，除了count(*)
  2. sum和avg一般用于处理数值型max、min、count可以处理任何数据类型
  3. 都可以搭配distinct使用，用于统计去重后的结果
  4. count的参数可以支持：字段、*、常量值，一般放1,建议使用 count(*)

*** 分组查询
+ 语法
  士大夫
	#+begin_src sql
	 select 查询的字段，分组函数
	 from 表
	 group by 分组的字段
  #+end_src

+ 特点：
	1. 可以按单个字段分组
	2. 和分组函数一同查询的字段最好是分组后的字段
	3. 分组筛选: 针对的表	位置 关键字

	   + 分组前筛选：	原始表		group by的前面		where

     + 分组后筛选：	分组后的结果集	group by的后面		having

	4. 可以按多个字段分组，字段之间用逗号隔开
	5. 可以支持排序
	6. having后可以支持别名

*** 多表连接查询

笛卡尔乘积：如果连接条件省略或无效则会出现

解决办法：添加上连接条件

**** 传统模式下的连接 ：等值连接——非等值连接

1. 等值连接的结果 = 多个表的交集
2. n表连接，至少需要n-1个连接条件
3. 多个表不分主次，没有顺序要求
4. 一般为表起别名，提高阅读性和性能
**** sql99语法：通过join关键字实现连接
1. 含义：1999年推出的sql语法
2. 支持：

   等值连接

   非等值连接 （内连接）

   外连接

   交叉连接

3. 语法：
   #+begin_src sql
	select 字段，...
	from 表1
	【inner|left outer|right outer|cross】join 表2 on  连接条件
	【inner|left outer|right outer|cross】join 表3 on  连接条件
	【where 筛选条件】
	【group by 分组字段】
	【having 分组后的筛选条件】
	【order by 排序的字段或表达式】
   #+end_src

	好处：语句上，连接条件和筛选条件实现了分离，简洁明了！


**** 自连接

+ 案例：查询员工名和直接上级的名称
  #+begin_src sql
    -- sql99

     SELECT e.last_name,m.last_name
     FROM employees e
     JOIN employees m ON e.`manager_id`=m.`employee_id`;

    -- sql92

     SELECT e.last_name,m.last_name
     FROM employees e,employees m
     WHERE e.`manager_id`=m.`employee_id`;
#+end_src

*** 子查询
一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询，在外面的查询语句，称为主查询或外查询

特点：

	1. 子查询都放在小括号内
	2. 子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧
	3. 子查询优先于主查询执行，主查询使用了子查询的执行结果
	4. 子查询根据查询结果的行数不同分为以下两类：
     + 单行子查询

		 结果集只有一行

       一般搭配单行操作符使用：> < = <> >= <=

		 非法使用子查询的情况：

		 a. 子查询的结果为一组值

		 b. 子查询的结果为空

	 + 多行子查询

		 结果集有多行

       一般搭配多行操作符使用：any、all、in、not in

       in： 属于子查询结果中的任意一个就行

       any和all往往可以用其他查询代替

*** 分页查询
+ 应用场景：实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句

+ 语法：
  #+begin_src sql
	select 字段|表达式,...
	from 表
	【where 条件】
	【group by 分组字段】
	【having 条件】
	【order by 排序的字段】
	limit 【起始的条目索引，】条目数;
  #+end_src
+ 特点：
	1. 起始条目索引从0开始
	2. limit子句放在查询语句的最后
	3. 公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage

       假如:每页显示条目数sizePerPage要显示的页数 page

*** 联合查询
+ 引入：

	union 联合、合并

+ 语法：
  #+begin_src sql
	select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
	select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
	select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】
	.....
	select 字段|常量|表达式|函数 【from 表】 【where 条件】
  #+end_src
+ 特点：
	1. 多条查询语句的查询的列数必须是一致的
	2. 多条查询语句的查询的列的类型几乎相同
	3. union代表去重，union all代表不去重

*** DML语言
**** 插入
+ 语法：
  #+begin_src sql
	insert into 表名(字段名，...)
	values(值1，...);
  #+end_src
+ 特点：
  1. 字段类型和值类型一致或兼容，而且一一对应
  2. 可以为空的字段，可以不用插入值，或用null填充
  3. 不可以为空的字段，必须插入值
  4. 字段个数和值的个数必须一致
  5. 字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致
**** 修改
+ 修改单表语法：
  #+begin_src sql
	update 表名 set 字段=新值,字段=新值
	【where 条件】
  #+end_src
+ 修改多表语法：
  #+begin_src sql
	update 表1 别名1,表2 别名2
	set 字段=新值，字段=新值
	where 连接条件
	and 筛选条件
  #+end_src
**** 删除
***** 方式1：delete语句
+ 单表的删除： ★
  #+begin_src sql
	delete from 表名 【where 筛选条件】
  #+end_src
+ 多表的删除：
  #+begin_src sql
	delete 别名1，别名2
	from 表1 别名1，表2 别名2
	where 连接条件
	and 筛选条件;
  #+end_src

***** 方式2：truncate语句
#+begin_src sql
	truncate table 表名
#+end_src
***** 两种方式的区别
	1. truncate不能加where条件，而delete可以加where条件
	2. truncate的效率高一丢丢
	3. truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始,delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始
	4. truncate删除不能回滚，delete删除可以回滚
*** DDL语句
**** 库和表的管理
***** 库的管理：
+ 创建库
  #+begin_src sql
	create database 库名
  #+end_src
+ 删除库
  #+begin_src sql
	drop database 库名
  #+end_src
***** 表的管理：
1. 创建表
   #+begin_src sql
	   CREATE TABLE IF NOT EXISTS stuinfo(
		  stuId INT,
		  stuName VARCHAR(20),
		  gender CHAR,
		  bornDate DATETIME
	  );
#+end_src

2. 修改表alter

   #+begin_src sql
     -- 语法：
        ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;
     -- 修改字段名
     ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;
     -- 修改表名
     ALTER TABLE stuinfo RENAME [TO]  studentinfo;
     -- 修改字段类型和列级约束
     ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;
     -- 添加字段
     ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;
     -- 删除字段
     ALTER TABLE studentinfo DROP COLUMN email;
   #+end_src

3. 删除表
#+begin_src sql
	DROP TABLE [IF EXISTS] studentinfo;
#+end_src


*** 常见类型
+ 整型：
+ 小数：浮点型,定点型
+ 字符型：
+ 日期型：
+ Blob类型：
*** 常见约束
+ NOT NULL
+ DEFAULT
+ UNIQUE
+ CHECK
+ PRIMARY KEY
+ FOREIGN KEY
*** 数据库事务
+ 含义:

  通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态

+ 特点（ACID）
	1. 原子性：要么都执行，要么都回滚
	2. 一致性：保证数据的状态操作前和操作后保持一致
	3. 隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰
	4. 持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改

+ 相关步骤：
	1. 开启事务
	2. 编写事务的一组逻辑操作单元（多条sql语句）
	3. 提交事务或回滚事务

*** 事务的分类：
+ 隐式事务，没有明显的开启和结束事务的标志

	比如insert、update、delete语句本身就是一个事务

+ 显式事务，具有明显的开启和结束事务的标志
	1. 开启事务取消自动提交事务的功能
	2. 编写事务的一组逻辑操作单元（多条sql语句）insert,update,delete
	3. 提交事务或回滚事务
*** 事务使用到的关键字
	set autocommit=0;

	start transaction;

  commit;

  rollback;

	savepoint  断点

	commit to 断点

	rollback to 断点

*** 事务的隔离级别:
事务并发问题如何发生？

当多个事务同时操作同一个数据库的相同数据时事务的并发问题有哪些？
+ 脏读：一个事务读取到了另外一个事务未提交的数据
+ 不可重复读：同一个事务中，多次读取到的数据不一致
+ 幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据

如何避免事务的并发问题？通过设置事务的隔离级别
	1. READ UNCOMMITTED
	2. READ COMMITTED 可以避免脏读
	3. REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读
	4. SERIALIZABLE可以避免脏读、不可重复读和幻读

设置隔离级别：

	set session|global  transaction isolation level 隔离级别名;

查看隔离级别：

	select @@tx_isolation;

*** 视图
+ 含义：理解成一张虚拟的表
+ 视图和表的区别：

  使用方式	占用物理空间

	视图	完全相同	不占用，仅仅保存的是sql逻辑

	表	完全相同	占用

+ 视图的好处：
	1. sql语句提高重用性，效率高
	2. 和表实现了分离，提高了安全性

*** 视图的创建
+ 语法：
  #+begin_src sql
    CREATE VIEW  视 图名
    AS
    查询语句;
  #+end_src
**** 视图的增删改查
1. 查看视图的数据 ★
   #+begin_src sql
	SELECT * FROM my_v4;
	SELECT * FROM my_v1 WHERE last_name='Partners';
    #+end_src
2. 插入视图的数据
   #+begin_src sql
	INSERT INTO my_v4(last_name,department_id) VALUES('虚竹',90);
   #+end_src
3. 修改视图的数据
   #+begin_src sql
	UPDATE my_v4 SET last_name ='梦姑' WHERE last_name='虚竹';
   #+end_src

4. 删除视图的数据
   #+begin_src sql
    DELETE FROM my_v4;
   #+end_src
**** 某些视图不能更新
#+begin_src sql
	-- 包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all
	-- 常量视图
	Select中包含子查询
	join
	from 一个不能更新的视图
	where子句的子查询引用了from子句中的表
#+end_src
**** 视图逻辑的更新
+ 方式一：
  #+begin_src sql
	CREATE OR REPLACE VIEW test_v7
	AS
	SELECT last_name FROM employees
	WHERE employee_id>100;
    #+end_src
+ 方式二:
  #+begin_src sql
	ALTER VIEW test_v7
	AS
	SELECT employee_id FROM employees;

	SELECT * FROM test_v7;
    #+end_src
**** 视图的删除
	DROP VIEW test_v1,test_v2,test_v3;
**** 视图结构的查看
	DESC test_v7;

	SHOW CREATE VIEW test_v7;
*** 存储过程
+ 含义：一组经过预先编译的sql语句的集合
+ 好处：
	1. 提高了sql语句的重用性，减少了开发程序员的压力
	2. 提高了效率
	3. 减少了传输次数
+ 分类：
	1. 无返回无参
	2. 仅仅带in类型，无返回有参
	3. 仅仅带out类型，有返回无参
	4. 既带in又带out，有返回有参
	5. 带inout，有返回有参

注意：in、out、inout都可以在一个存储过程中带多个
**** 创建存储过程
+ 语法：
  #+begin_src sql
	create procedure 存储过程名(in|out|inout 参数名  参数类型,...)
	begin
		存储过程体
	end
  #+end_src
类似于方法：
#+begin_src java
	修饰符 返回类型 方法名(参数类型 参数名,...){
		方法体;
	}
#+end_src
+ 注意
  1. 需要设置新的结束标记

	delimiter 新的结束标记

	示例：

	delimiter $
    #+begin_src sql
	CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)
	BEGIN
		sql语句1;
		sql语句2;
	END $
    #+end_src
  2. 存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end
  3. 参数前面的符号的意思

	 in:该参数只能作为输入 （该参数不能做返回值）

	 out：该参数只能作为输出（该参数只能做返回值）

	 inout：既能做输入又能做输出
**** 调用存储过程
call 存储过程名(实参列表)
*** 函数
**** 创建函数
学过的函数：LENGTH、SUBSTR、CONCAT等
+ 语法：
  #+begin_src sql
	CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型
	BEGIN
		函数体
	END
#+end_src
**** 调用函数
SELECT 函数名（实参列表）
*** 函数和存储过程的区别
| 关键字   | 调用语法                     | 返回值          | 应用场景                                                 |
|----------+------------------------------+-----------------+----------------------------------------------------------|
|          |                              |                 |                                                          |
| 函数     | FUNCTION	SELECT 函数()    | 只能是一个      | 一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个 |
|          |                              |                 |                                                          |
| 存储过程 | PROCEDURE	CALL 存储过程() | 可以有0个或多个 | 一般用于更新                                             |
|          |                              |                 |                                                          |

*** 流程控制结构
**** 系统变量
1. 全局变量
   作用域：针对于所有会话（连接）有效，但不能跨重启
   #+begin_src sql
     -- 查看所有全局变量
     SHOW GLOBAL VARIABLES;
     -- 查看满足条件的部分系统变量
     SHOW GLOBAL VARIABLES LIKE '%char%';
     -- 查看指定的系统变量的值
     SELECT @@global.autocommit;
     -- 为某个系统变量赋值
     SET @@global.autocommit=0;
     SET GLOBAL autocommit=0;
    #+end_src
2. 会话变量
   作用域：针对于当前会话（连接）有效
   #+begin_src sql
	-- 查看所有会话变量
	SHOW SESSION VARIABLES;
	-- 查看满足条件的部分会话变量
	SHOW SESSION VARIABLES LIKE '%char%';
	-- 查看指定的会话变量的值
	SELECT @@autocommit;
	SELECT @@session.tx_isolation;
	-- 为某个会话变量赋值
	SET @@session.tx_isolation='read-uncommitted';
	SET SESSION tx_isolation='read-committed';
   #+end_src
**** 自定义变量
1. 用户变量
   + 声明并初始化：
     #+begin_src sql
       SET @变量   名=值;
       SET @变量名:=值;
       SELECT @变量名:=值;
    #+end_src
   + 赋值：
     #+begin_src sql
       -- 方式一：一般用于赋简单的值
       SET 变量名=值;
       SET 变量名  :=值;
       SELECT 变量名:=值;
       -- 方式二：一般用于赋表 中的字段值
       SELECT 字段名或表达式 INTO 变量
       FROM 表;
    #+end_src

   + 使用

	 select @变量名;

2. 局部变量
   #+begin_src sql
     -- 声明：
             declare 变量名 类型 【default 值】;
     -- 赋值：

         -- 方式一：一般用于赋简单的值
         SET 变量名=值;
         SET 变量名:=值;
         SELECT 变量名:=值;

         -- 方式二：一般用于赋表 中的字段值
         SELECT 字段名或表达式 INTO 变量
         FROM 表;

     -- 使用：
         select 变量名
#+end_src


二者的区别：

| 变量     | 作用域              | 定义位置        | 语法                             |
|----------+---------------------+-----------------+----------------------------------|
|          |                     |                 |                                  |
| 用户变量 | 当前会话            | 会话的任何地方  | 加@符号，不用指定类型            |
| 局部变量 | 定义它的BEGIN END中 | BEGIN END的第一 | 句话	一般不用加@,需要指定类型 |
|          |                     |                 |                                  |
*** 分支
1. if函数
   语法：if(条件，值1，值2)

   特点：可以用在任何位置

2. case语句

  语法：
  #+begin_src sql
    -- 情况一：类似于switch
    case 表达式
    when 值1 then 结果1或语句1(如果是语句，需要加分号)
    when 值2 then 结果2或语句2(如果是语句，需要加分号)
    ...
    else 结果n或语句n(如果是语句，需要加分号)
    end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）

    -- 情况二：类似于多重if
    case
    when 条件1 then 结果1或语句1(如果是语句，需要加分号)
    when 条件2 then 结果2或语句2(如果是语句，需要加分号)
    ...
    else 结果n或语句n(如果是语句，需要加分号)
         end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）

  #+end_src
特点：可以用在任何位置

3. if elseif语句

语法：
#+begin_src sql
	if 情况1 then 语句1;
	elseif 情况2 then 语句2;
	...
	else 语句n;
	end if;
#+end_src
特点：只能用在begin end中！！！！！！！！！！！！！！！

三者比较：
	| 分支     | 应用场合         |
	|----------+------------------|
	|          |                  |
	| if函数   | 简单双分支       |
	| case结构 | 等值判断的多分支 |
	| if结构   | 区间判断的多分支 |

*** 循环
语法：
#+begin_src sql
	【标签：】WHILE 循环条件  DO
		循环体
	END WHILE 【标签】;
#+end_src
特点：
	+ 只能放在BEGIN END里面
	+ 如果要搭配leave跳转语句，需要使用标签，否则可以不用标签
	+ leave类似于java中的break语句，跳出所在循环！！！


** DONE Element UI Form表单自定义验证规则                    :@Element:Form:Valid:
:PROPERTIES:
:EXPORT_FILE_NAME: 2022-11-19-elementui-form-item-valid
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-19 周六 09:17]
:END:
Form表单提供了表单校验功能，只需要通过rules属性传入特定的验证规则，并将Form-Item的prop属性设置为需要校验的字段名即可。
*** 普通表单验证
具体可见[[https://element.eleme.cn/#/zh-CN/component/form]]
#+begin_src vue
<el-form :model="ruleForm" :rules="rules" ref="ruleForm" label-width="100px" class="demo-ruleForm">
  <el-form-item label="活动名称" prop="name">
    <el-input v-model="ruleForm.name"></el-input>
  </el-form-item>
</el-form>
<script>
  export default {
    data() {
      return {
        ruleForm: {
          name: '',
        },
        rules: {
          name: [
            { required: true, message: '请输入活动名称', trigger: 'blur' },
            { min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' }
          ],
        }
      };
    },
    methods: {
      submitForm(formName) {
        this.$refs.ruleForm.validate((valid) => {
          if (valid) {
            alert('submit!');
          } else {
            console.log('error submit!!');
            return false;
          }
        });
      },

    }
  }
</script>

#+end_src
*** 自定义验证规则
+ 定义规则校验方法：比如判断密码是否为空
  #+begin_src js
    checkPass:function (rule, value, callback) => {
        if (value === '') {
          callback(new Error('请输入密码'));
        } else {
          if (this.ruleForm.checkPass !== '') {
            this.$refs.ruleForm.validateField('checkPass');
          }
          callback();
        }
      };
  #+end_src
  + rule属性中使用 *[validator: 校验方法]* 即可
    #+begin_src js
      rules: {
        checkPass: [
          {validator: checkPass, trigger: blur}
          ]
        }
#+end_src
*** 常用的校验
#+begin_src js
   // 邮箱验证
   checkEmail: function (rule, value, callback) {
     const regEmail = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
     if (regEmail.test(value)) {
       return callback();
     }
     callback(new Error("邮箱格式有误"));
   },

   //手机号验证
   checkMobile: function(rule, value, callback) {
     const regMobile = /^(0|86|17951)?(13[0-9]|15[012356789]|17[3678]|18[0-9]|14[57])[0-9]{8}$/;
     if (regMobile.test(value)) {
       return callback();
     }
     callback(new Error("手机号格式有误"));
   },

   //身份证号码校验
   checkIDCard: function(rule, value, callback) {
     const regIDCard = /^\d{6}(18|19|20)?\d{2}(0[1-9]|1[0-2])(([0-2][1-9])|10|20|30|31)\d{3}(\d|X|x)$/;
     if (regIDCard.test(value)) {
       return callback();
     }
     callback(new Error("身份证号格式有误"));
   },

   //社会信用代码, 例如：12500114709462931G
   checkSCC: function(rule, value, callback) {
     //同时支持18位和15位社会信用代码 Social Credit Code
     const regSCC = /^([0-9A-HJ-NPQRTUWXY]{2}\d{6}[0-9A-HJ-NPQRTUWXY]{10}|[1-9]\d{14})$/;
     if (value) {
       if (regSCC.test(value)) {
         callback();
       } else {
         callback(new Error("社会信用代码格式有误"));
       }
     } else {
       callback(new Error("请输入统一社会信用代码"));
     }
   }
   // 密码格式校验
   checkPwd: function (rule, value, callback) {
       let pattern = /^(?=.*[\d])(?=.*[a-zA-Z]).{8,}$/;
       if (!pattern.test(value)) {
         callback(
           new Error("密码必须包含数字、字母(区分大小写)，且长度为8位~20位")
         );
       } else {
         callback();
       }
  };


#+end_src


** DONE MingW使用git status时显示中文乱码                  :@Git:MingW:乱码:
:PROPERTIES:
:EXPORT_FILE_NAME: 2022-11-19-git-mingw-中文乱码
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-19 周六 09:38]
:END:
#+begin_src shell
git config --global core.quotepath false
#+end_src

** TODO 进制的转换                                              :@Java:进制:
:PROPERTIES:
:EXPORT_FILE_NAME: 2022-11-21-java-进制转换
:END:
*** java 中进制的分类：进制前缀不参与运算
+ 十六进制：逢十六进一:开头加0x
  1. 大于十的数用字母来代替：10->A,11->B,12->C,13->D,14->E,15->F
  2. 书写方式：开头加0x
  3. 示例：0xAF87D
+ 十进制：逢八进一：正常书写
  1. 书写方式：正常书写
  2. 例子：12，5，123
+ 八进制：逢八进一：开头加0
  1. 书写方式: 开头加0
  2. 示例：01234，0127
+ 二进制：逢二进一：开头加0b
  1. 书写方式：开头加0b
  2. 示例：0b0101010
*** 进制之间的换算
在计算机中，数据最终都会变成二进制，也就是由多个1或者0组成的，而每一个1或者0都称为一个位（bit）, *在计算机中进行存储和运算的最小单位十字节（byte）*

*各单位之间的换算大小* ： *bit->8->byte->0124->KB->1024->MB->1024->GB->1024->TB*
